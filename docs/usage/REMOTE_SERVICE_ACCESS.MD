## Accessing Remote Microservices

- [Accessing Remote Microservices Synchronously](#synchronous)
  - [Declarative Fetch of Sub-Entities From Remote Backk Microservices](#fetchfromremoteservice)
  - [Call Remote Backk Microservice](#callremoteservice)
  - [Make HTTP Requests](#makehttprequest)
- [Accessing Remote Backk Microservices Asynchronously](#asynchronous)
  - [Send to Remote Backk Microservice via Kafka](#sendtokafka)
  - [Send to Remote Backk Microservice via Redis](#sendtoredis)
  - [Send Multiple Request to Remote Backk Microservices via Kafka inside Transaction](#sendtokafkainsidetransaction)

### <a name="synchronous"></a> Accessing Remote Microservices Synchronously
There are three different ways to synchronously access remote microservices from your current Backk microservice:
1. Declarative fetch of sub-entities from another remote Backk microservice
2. Call another Backk microservice to synchronously fetch data
3. Make a generic HTTP request to any HTTP based (non-Backk) microservice

#### <a name="fetchfromremoteservice"></a> Declarative Fetch of Sub-Entities From Remote Backk Microservice
In the below example, Backk microservice `user-account-service` has an entity named `UserAccount`.
When a `UserAccount` entity is fetched from data store at the same time also user's own sales items are fetched
automatically from a remote Backk microservice named `sales-item-service`, where service function named
`salesItemService.getUsersSalesItem` is called with argument containing `userAccountId`.

The first argument of `@FetchFromRemoteService` decorator is the name of the remote Backk microservice.
The second argument is the name of the remote service function to be called.
The third argument is service function argument builder that is a function which receives current service
function call argument and response as arguments and then returns the argument to be sent to a remote service function.

Entity properties annotated with `@FetchFromRemoteService` are always implicitly read-only properties.

In the below example, user's own sales items are fetched from remote `sales-item-service` microservice using service function
`salesItemService.getUsersSalesItems`. `{ userAccountId: <your user account id> }` will be sent as the argument for the remote service function call. For example, if you request service function `userAccountService.getUserAccount` that returns a `UserAccount`,
you will get your own sales items automatically fetched from the remote microservice. 

```ts
import { FetchFromRemoteService, ReadOnly } from 'backk';

class UserAccount extends BaseUserAccount {
  @FetchFromRemoteService('sales-item-service', 'salesItemService.getUsersSalesItems', (arg, response) => ({
    userAccountId: response._id
  }))
  ownSalesItems: any[];
}
```

Properties annotated with `@FetchFromRemoteService` decorator can have type `any[]`.
Current request´s authorization header is added automatically to the remote request generated by `@FetchFromRemoteService` decorator.

`@FetchFromRemoteService` accepts fourth argument which is the Kubernetes namespace of the remote microservice.
By default, it is the same as microservice calling the remote microservice. 

`@FetchFromRemoteService` accepts fifth argument `options?: HttpRequestOptions` where HTTP method can be specified, default is POST:

```ts
interface HttpRequestOptions {
  httpMethod?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  httpVersion?: 1 | 2;
  tls?: {
    ca?: string | Buffer | Array<string | Buffer>;
    cert?: string | Buffer | Array<string | Buffer>;
    key?: string | Buffer | Array<Buffer | KeyObject>;
  };
}
```

#### <a name="callremoteservice"></a> Call Remote Backk Microservices
Backk microservice can easily call service functions in another Backk microservice using `callRemoteService` function.
The below example calls service function `salesItemService.getUsersSalesItems` in Backk microservice `sales-item-service`,
giving `userAccountId` as service function argument. Current request´s authorization header is added to the new request automatically.

```ts
import { callRemoteService } from 'backk';

callRemoteService(
  'sales-item-service',
  'salesItemService.getUsersSalesItems',
  {
    userAccountId
  }
);
```

`callRemoteService` accepts fourth argument which is the Kubernetes namespace of the remote microservice.
By default, it is the same as microservice calling the remote microservice.

`callRemoteService` accepts fifth argument `options?: HttpRequestOptions` where HTTP request options can be specified:

```ts
interface HttpRequestOptions {
  httpMethod?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  httpVersion?: 1 | 2;
  tls?: {
    ca?: string | Buffer | Array<string | Buffer>;
    cert?: string | Buffer | Array<string | Buffer>;
    key?: string | Buffer | Array<Buffer | KeyObject>;
  };
}
```

#### <a name="makehttprequest"></a> Make HTTP Requests
Accessing non-Backk microservices and HTTP endpoints from Backk microservice is easy using `makeHttpRequest` function.
`makeHttpRequest` will accept `requestUrl` argument and `requestBodyObject` which is serialized to JSON and sent in request body. The HTTP request
is always made with content type `application/json`. Current request´s authorization header is added to the new request automatically.

```ts
function makeHttpRequest(
  requestUrl: string,
  requestBodyObject?: object,
  options?: HttpRequestOptions
): PromiseErrorOr<object | null>

interface HttpRequestOptions {
  httpMethod?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  httpVersion?: 1 | 2;
  tls?: {
    ca?: string | Buffer | Array<string | Buffer>;
    cert?: string | Buffer | Array<string | Buffer>;
    key?: string | Buffer | Array<Buffer | KeyObject>;
  };
}
```

### <a name="synchronous"></a> Accessing Remote Backk Microservices Asynchronously
There are three different ways to access asynchronously remote Backk microservices from your Backk microservice.

1. Sending a remote service function call request to Kafka, 
2. Sending a remote service function call request to Redis.
3. Access multiple remote Backk microservices via Kafka inside a transaction.

#### <a name="sendtokafka"></a> Send to Remote Backk Microservice via Kafka
Sending a service function request to a remote Backk microservice via Kafka can be achieved with a call to `sendToRemoteService` function with `communicationMethod` of `kafka`.
The remote Backk microservice should have a [`KafkaConsumer` request processor](../api/MICROSERVICE_INITIALIZATION.MD#kafka-consumer) running for consuming service function request from other Backk microservices.

```ts
async function sendToRemoteService(
  communicationMethod: 'kafka' | 'redis',
  microserviceName: string,
  serviceFunctionName: string,
  serviceFunctionArgument: object,
  microserviceNamespace = process.env.MICROSERVICE_NAMESPACE,
  server?: string,
  responseDestination?: ResponseDestination,
  options?: SendOptions
): PromiseErrorOr<null>

interface ResponseDestination {
  communicationMethod: CommunicationMethod;
  microserviceName: string;
  microserviceNamespace: string | undefined;
  serviceFunctionName: string;
  server: string;
}

type CommunicationMethod = 'http' | 'kafka' | 'redis'

interface SendOptions {
  compressionType?: CompressionTypes;
  sendAcknowledgementType?: SendAcknowledgementType;
}

enum CompressionTypes {
  None = 0, // Default
  GZIP = 1,
  Snappy = 2,
  LZ4 = 3,
  ZSTD = 4,
}

enum SendAcknowledgementType {
  NONE,
  LEADER_ONLY,
  ALL_REPLICAS = -1 // Default
}
```

In the below example a service function call request for service function `refundService.refundOrder` in
Backk microservice named `refund-service` is sent to Kafka with service function argument containing the `orderId`:

```ts
sendToRemoteService('kafka', 'refund-service', `refundService.refundOrder`, { orderId: _id })
```

As the fifth argument to `sendToRemoteService` function, the Kubernetes namespace of target remote Backk microservice
can be specified. The default value is the same namespace as for current microservice.

The sixth argument of `sendToRemoteService` function specifies the Kafka server in the form of <hostname>:<port>
By default, the Kafka server info is extracted from environment variables `KAFKA_HOST` and `KAFKA_PORT`.

The seventh argument of `sendToRemoteService` function specifies the response destination for the
response from the async remote service function call.

#### <a name="sendtoredis"></a> Send to Remote Backk Microservice via Redis
Sending service function request to a remote Backk microservice via Redis can be achieved with a call to `sendToRemoteService` function with `communicationMethod` of `redis`.
The remote Backk microservice should have a [`RedisConsumer` request processor](../api/MICROSERVICE_INITIALIZATION.MD#redis-consumer) running for consuming service function request from other Backk microservices.

```ts
async function sendToRemoteService(
  communicationMethod: 'kafka' | 'redis',
  microserviceName: string,
  serviceFunctionName: string,
  serviceFunctionArgument: object,
  microserviceNamespace = process.env.MICROSERVICE_NAMESPACE,
  server?: string,
  responseDestination?: ResponseDestination,
  options?: SendOptions
): PromiseErrorOr<null>

interface ResponseDestination {
  communicationMethod: CommunicationMethod;
  microserviceName: string;
  microserviceNamespace: string | undefined;
  serviceFunctionName: string;
  server: string;
}

type CommunicationMethod = 'http' | 'kafka' | 'redis'

interface SendOptions {
  compressionType?: CompressionTypes;
  sendAcknowledgementType?: SendAcknowledgementType;
}

enum CompressionTypes {
  None = 0, // Default
  GZIP = 1,
  Snappy = 2,
  LZ4 = 3,
  ZSTD = 4,
}

enum SendAcknowledgementType {
  NONE,
  LEADER_ONLY,
  ALL_REPLICAS = -1 // Default
}
```

In the below example a service function call request for service function `refundService.refundOrder` in
Backk microservice named `refund-service` is sent to Redis with service function argument containing the `orderId`:

```ts
sendToRemoteService('redis', 'refund-service', `refundService.refundOrder`, { orderId: _id })
```

As the fifth argument to `sendToRemoteService` function, the Kubernetes namespace of target remote Backk microservice
can be specified. The default value is the same namespace as for current microservice.

The sixth argument of `sendToRemoteService` function specifies the Redis server in the form of <hostname>:<port>
By default, the Redis server info is extracted from environment variables `REDIS_HOST` and `REDIS_PORT`.

The seventh argument of `sendToRemoteService` function specifies the response destination for the
response from the async remote service function call.

#### <a name="sendtokafkainsidetransaction"></a> Send Multiple Request to Remote Backk Services via Kafka inside Transaction
This is for sending multiple remote service function call requests simultaneously inside transaction to Kafka.
All the remote service function call requests must happen to the same Kafka server.
Transactions are not supported by Redis.

```ts
function sendToRemoteServiceInsideTransaction(transmissions: Transmission[]);

interface Transmission {
  communicationMethod: 'kafka';
  microserviceName: string;
  serviceFunctionName: string;
  serviceFunctionArgument: object;
  microserviceNamespace?: string;
  server?: string;
  responseDestination?: ResponseDestination;
  options?: SendOptions;
}

interface ResponseDestination {
  communicationMethod: CommunicationMethod;
  microserviceName: string;
  microserviceNamespace: string | undefined;
  serviceFunctionName: string;
  server: string;
}

type CommunicationMethod = 'http' | 'kafka' | 'redis'

interface SendOptions {
  compressionType?: CompressionTypes;
  sendAcknowledgementType?: SendAcknowledgementType;
}

enum CompressionTypes {
  None = 0, // Default
  GZIP = 1,
  Snappy = 2,
  LZ4 = 3,
  ZSTD = 4,
}

enum SendAcknowledgementType {
  NONE, 
  LEADER_ONLY,
  ALL_REPLICAS = -1 // Default
}
```
